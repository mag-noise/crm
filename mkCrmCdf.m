function [cOutFile] = mkCrmCdf(cInFile)
% Convert a CRM matlab file into an ISTP compliant CDF
%
% [cOutFile] = mkCrmCdf(cInFile)
%
% Params:
%   cInFile (char vec)
%     The name of the input matlab file to convert to a CDF file.
%
% Returns:
%   cOutFile (char vec)
%     The name of the CDF file created.
%
% TODO: 
%   1. Get the date on which Matt's files were created and update the
%      Logical_file_id global file attribute.
%   
%   2. Find out what the different combination numbers mean and convey
%      this meaning in global attributes and varible descriptions
	
	nHertz = 200;  % the sample rate

	% Load the file and set component info
	[nComboId, nTrendId, nInterId, nGeoId, ...
		cTrendInfo, cInterInfo, cGeoInfo, tData] = loadL2_(cInFile);
	
	out = cdf.CDF();  % Empty CDF object
	
	% Write in global identifing attributes
	out.attr('Data_type') = {'H0>High Resolution Data'};
	out.attr('Data_version') = {1};
	out.attr('Descriptor') = {'CRM>Interference Mitigation Algorithm Validation'};
	out.attr('Discipline') = {'Space Physics>Magnetospheric Science'};
	out.attr('Generated_by') = {'Finley, M.G. - University of Iowa'};
	out.attr('Instrument_type') = {'Magnetic Fields'};
	out.attr('Logical_file_id') = {...
		sprintf('CRM_H0_MAG_20230101_Trend%d_Inter%d_GeoPhys%d_V01', nTrendId, nInterId, nGeoId...
	)};
	
	out.attr('Text_supplemental') = {...
		['This file is one particular combination of laboratory generated signals intended to enable '...
		 'numerical analysis of existing and future interference mitigation techniques for in-situ magnetic field data. ' ...
		 'The full dataset consists of ~10 hours of magnetic field data from four sensors. '...
		 'It contains data exhibiting large near-DC trends, physically synthesized reaction '...
		 'wheel interference, and pseudo-geomagnetic phenomena. Further, each measurement '...
		 'interval of these three broad data categories were captured individually prior to '...
		 'their combination, effectively providing a ground-truth for the magnetic '...
		 'interference and residual geophysical fields, such that the performance of interference '...
		 'mitigation techniques can be rigorously quantified.']...
		 ['This combination, ' sprintf('%d', nComboId) ', combines a near-DC trend, an interference '...
		 'signal and a pseudo geomagnetic signal.  These were generated in the following manner:'], ...
		['Near DC Trend: ' cTrendInfo ],...
		['Interference:  ' cInterInfo ],...
		['Pseudo-Geomagnetic: ' cGeoInfo],...
		'For more information on the component and combined fields see Finley, M.G. et. al, 2023'...
	};

	out.attr('Parents') = {[...
		tData.L2_SourceFiles.TrendSource ', ' ...
		tData.L2_SourceFiles.IntSource ', ' ...
		tData.L2_SourceFiles.GeoSource ...
	]};
	
	out.attr('PI_affiliation') = {'The University of Iowa'};
	out.attr('PI_name') = {'Miles, D.'};
	out.attr('Project') = {'Constellation Ready Mag'};
	out.attr('Rules_of_use') = {...
		['Cite Finley, M.G. et. al. 2023 in publications that make use of this dataset or its derivatives.']
	};

	out.attr('Source_name') = {'CRM>Constellation Ready Magnetometers'};
	out.attr('TEXT') = {'DOI of Journal article goes here'};
	out.attr('Time_resolution') = {sprintf('%d Hz', nHertz)};
	
	out.attr('TITLE') = {'CRM - Interference Benchmarks'};
	
	% Define some string constants for less typing
	cV = 'VAR_TYPE';
	cU = 'UNITS';
	cD = 'CATDESC';
	cMax = 'VALIDMAX';
	rMax = 6e+4;
	cMin = 'VALIDMIN';
	rMin = -6e+4;
	cFill = 'FILLVAL';
	% Manually set the bit pattern so that "scary" negative nans go away.
	rNan = hex2num('7ff8000000000000');
	cF = 'FIELDNAM';
	cD0 = 'DEPEND_0';
	cL1 = 'LABL_PTR_1';
	cN = 'VAR_NOTES';
	
	% The one and only time array, starts at zero point of the TT2000
	% time scale (changed my mind, use rough date of data generation)
	%t0 = datetime('2000-01-01T11:58:55.816Z', 'TimeZone', 'UTCLeapSeconds');
	
	% TODO: Find out when the files were generated
	t0 = datetime('2023-04-15T00:00:00.000Z', 'TimeZone', 'UTCLeapSeconds');
	
	N = height(tData.L2_Combined.L2_combined_1);
	aTime = t0 + seconds( (1:N)/nHertz );
	out.mkVar('Epoch', aTime, cU, 'UTC', cD, 'Measurement Time', cV, 'support_data');
	
	% Combined data
	aFields = fieldnames(tData.L2_Combined);
	for iMag = 1:numel(aFields)
		% Question, what is a good name to ID each magnetometer?
		cDesc = sprintf('Combined Signal %d @ Mag%d', nComboId, iMag);
		out.mkVar(...
			sprintf('Combined%dMag%d', nComboId, iMag), tData.L2_Combined.(aFields{iMag})', ...
			cU, 'nT', cD, cDesc, cF, cDesc, cMax, rMax, cMin, rMin, cFill, rNan, ...
			cD0, 'Epoch', cL1, sprintf('LblCombined%dMag%d', nComboId, iMag), cV, 'data', ...
			cN, ['The full measured signal: Interference + Geophysical '...
			'Signal + Near-DC trend'] ...
		);
		
		cMag = sprintf('Mag%d', iMag);
		out.mkVar(...
			sprintf('LblCombined%dMag%d', nComboId, iMag), {...
			['Comb ' cMag ' Bx'];['Comb ' cMag ' By'];['Comb ' cMag ' Bz']...
			}, cD, ...
			sprintf('Component label for Combined%dMag%d', nComboId, iMag), cV, 'metadata' ...
		);
	end
	
	% Just the signal
	aFields = fieldnames(tData.L2_Geophysical);
	for iMag = 1:numel(aFields)
		
		cDesc = sprintf('Geophysical Signal %d @ Mag%d', nGeoId, iMag);
		out.mkVar(...
			sprintf('GeoSignal%dMag%d', nGeoId, iMag), tData.L2_Geophysical.(aFields{iMag})', ...
			cU, 'nT', cD, cDesc, cF, cDesc, cMax, rMax, cMin, rMin, cFill, rNan, ...
			cD0, 'Epoch', cL1, sprintf('LblGeoSignal%dMag%d', nGeoId, iMag), cV, 'data', ...
			cN, ['The external geophysical signal only. ' cGeoInfo] ...
		);
	
		cMag = sprintf('Mag%d', iMag);
		out.mkVar(...
			sprintf('LblGeoSignal%dMag%d', nGeoId, iMag), {...
			[cMag ' Bx'];[cMag ' By'];[cMag ' Bz']...
			}, cD, ...
			sprintf('Component label for GeoSignal%dMag%d', nGeoId, iMag), cV, 'metadata' ...
		);
	end
	
	% Just the interference
	aFields = fieldnames(tData.L2_Interference);
	for iMag = 1:numel(aFields)
		
		cDesc = sprintf('Local Interference Noise %d @ Mag%d', nInterId, iMag);
		out.mkVar(...
			sprintf('Inter%dMag%d', nInterId, iMag), tData.L2_Interference.(aFields{iMag})', ...
			cU, 'nT', cD, cDesc, cF, cDesc, cMax, rMax, cMin, rMin, cFill, rNan, ...
			cD0, 'Epoch', cL1, sprintf('LblInter%dMag%d', nInterId, iMag), cV, 'data', ...
			cN, ['The local interference noise only. ' cInterInfo] ...
		);
	
		cMag = sprintf('Mag%d', iMag);
		out.mkVar(...
			sprintf('LblInter%dMag%d', nInterId, iMag), {...
			['Noise ' cMag ' Bx'];['Noise ' cMag ' By'];['Noise ' cMag ' Bz']...
			}, cD, ...
			sprintf('Component label for Inter%dMag%d', nInterId, iMag), cV, 'metadata' ...
		);
	end
	
	% Just the trend
	aFields = fieldnames(tData.L2_Trend);
	for iMag = 1:numel(aFields)
		
		cDesc = sprintf('Near DC Trend %d @ Mag%d', nTrendId, iMag);
		out.mkVar(...
			sprintf('Trend%dMag%d', nTrendId, iMag), tData.L2_Trend.(aFields{iMag})', ...
			cU, 'nT', cD, cDesc, cF, cDesc, cMax, rMax, cMin, rMin, cFill, rNan, ...
			cD0, 'Epoch', cL1, sprintf('LblTrend%dMag%d', nTrendId, iMag), cV, 'data', ...
			cN, ['The near DC trend only. ' cTrendInfo] ...
		);
	
		cMag = sprintf('Mag%d', iMag);
		out.mkVar(...
			sprintf('LblTrend%dMag%d', nTrendId, iMag), {...
			['Trend ' cMag ' Bx'];['Trend ' cMag ' By'];['Trend ' cMag ' Bz']...
			}, cD, ...
			sprintf('Component label for Trend%dMag%d', nTrendId, iMag), cV, 'metadata' ...
		);
	end
	
	[cDir, cBase, ~] = fileparts(cInFile);
	
	if isempty(cDir) 
		cOutFile = ['CRM_' cBase '.cdf'];
	else
		cOutFile = [cDir filesep 'CRM_' cBase '.cdf'];
	end
	fprintf(['Writing file ' cOutFile '...' ]);
	out.save(cOutFile);
	fprintf(' done.\n');
	
end

%% Supporting functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %%

function [...
	nComboId, nTrendId, nInterId, nGeoId, cTrendInfo, cInterInfo, cGeoInfo, tData...
] = loadL2_(cInFile)

	[~, cName, ~] = fileparts(cInFile);

	% Info arrays for each source file
	
	% NOTE: cdflib.putAttrgEntry has a bug.  It assumes the number of bytes 
	%       to write to the attribute value in the file is the same as the
	%       number of characters in the input string.  For unicode points 
	%       above 127, this is NOT TRUE. To work around the problem add 1
	%       extra character for each extra utf-8 byte in the input string.
	%       -cwp
	lTrend = {...
		{'crm_trend_1_L1.mat', '0.001 Hz sine wave with 20 V amplitude applied to coil system X-axis'},...
		{'crm_trend_2_L1.mat', '0.003 Hz sine wave with 10 V amplitude applied to coil system Y-axis.'}...
		{'crm_trend_3_L1.mat', '0.002 Hz sine wave with 25 V amplitude applied to coil system Z-axis.'}...
		{'crm_trend_4_L1.mat', ['0.001 Hz sine waves with 15 V amplitude applied to X-, Y-, Z- axes;'...
        ' Phase offset φ = 0°, 30°, 90°, respectively.||||']}... % | = bug workaround
		{'crm_trend_5_L1.mat', ['0.001 Hz sine waves with 20 V amplitude applied to X-, Y-, Z- axes '...
		  'with no phase offsets.']}...
	};
	lInter = {...
		{'crm_int_1_L1.mat', 'Motor 1 & 2 driven at 2.5 V for duration.'}...
		{'crm_int_2_L1.mat', 'Motor 1 & 2 driven at 5 V for duration.'}...
		{'crm_int_3_L1.mat', 'Motor 1 driven at 3 V for duration. Motor 2 driven at 2.5 V for duration.'}...
		{'crm_int_4_L1.mat', ['Motor 1 driven at 5 V for start. After ~15-min, adjust down to 4 V. '...
		 'Motor 2 driven at 4 V for duration.']}...
		{'crm_int_5_L1.mat', ['Motor 1 driven at 5 V for duration. Motor 1 driven at 5 V for start. '...
		 'After ~15-min, adjust up to 7.5 V, then down to 2.5 V, then back to 5 V']}...
		{'crm_int_6_L1.mat', ['Motor 1 & 2 start at 7.5 V. After ~10-min, adjust down to 2.5 V. After '...
		 '~20-min, adjust up to 6 V.']}...
		{'crm_int_7_L1.mat', 'Motor 1 driven at 7 V for duration. Motor 2 driven at 6 V for duration.'}...
		{'crm_int_8_L1.mat', ['Motor 1 driven at 3 V for start. After ~10-min, adjust up to 8 V.'...
		 ' Motor 2 driven at 8 V for duration.']}...
	};
	lGeo = {...
		{'crm_geo_1_L1.mat', ['0.75 Hz sinusoid applied to X-axis coil former with amplitude '...
		 'swept from 0 V to 0.6 Vrms to 0 V.  Stimulus applied at ~10-min and ~20-min.']}...
		{'crm_geo_2_L1.mat', ['0.2 Vrms sinusoid applied to X-axis coil former with frequency '...
		 'swept from 0.75 Hz to 20 Hz. Stimulus applied at ~10-min and ~20-min.']}...
		{'crm_geo_3_L1.mat', ['5.0 Hz sinusoid applied to X-axis coil former with amplitude '...
		 'swept from 0 V to 0.6 Vrms to 0 V. Stimulus applied at ~10-min and ~20-min']}...
		{'crm_geo_4_L1.mat', ['10.0 Hz sinusoid applied to X-axis coil former with amplitude '...
		 'swept from 0 V to 0.6 Vrms to 0 V. Stimulus applied at ~10-min and ~20-min.']}...
		{'crm_geo_5_L1.mat', ['Vigorous ferromagnetic wrench-waving inside coil system performed '...
		 'by exemplary postdoc. Stimulus applied at ~5, 10, 15, 20, and 25-min']}...
		{'crm_geo_6_L1.mat', ['0.1 Vrms sinusoid applied to X-axis coil former with frequency swept '...
		 'from 0.75 Hz to 20 Hz.Stimulus applied at ~8, 16, and 24-min']}...
	};

	lName = split(cName, '_');
	if length(lName) < 3
		throw(MException('mkCrmCdf:BadName', ['File ' cInFile 
			' has less then three "_" separated components in the name']));
	end
	nComboId = str2num(lName{2});
	
	tData = load(cInFile);  % Load the data
	
	% Get the three primary dataset IDs
	nTrendId = sourceId_(tData.L2_SourceFiles.TrendSource);
	nInterId = sourceId_(tData.L2_SourceFiles.IntSource);
	nGeoId = sourceId_(tData.L2_SourceFiles.GeoSource);
	
	for i = 1:length(lTrend) 
		if isequal(tData.L2_SourceFiles.TrendSource, lTrend{i}{1})
			cTrendInfo = lTrend{i}{2};
			break;
		end
	end
	for i = 1:length(lInter) 
		if isequal(tData.L2_SourceFiles.IntSource, lInter{i}{1})
			cInterInfo = lInter{i}{2};
			break;
		end
	end
	for i = 1:length(lGeo) 
		if isequal(tData.L2_SourceFiles.GeoSource, lGeo{i}{1})
			cGeoInfo = lGeo{i}{2};
			break;
		end
	end
	
	if isempty(cTrendInfo)
		throw(MException('mkCrmCdf:UnkSrc',['Unknown Near-DC Trend file "' tData.L2_SourceFiles.TrendSource '"' ]));
	end
	if isempty(cInterInfo) 
		throw(MException('mkCrmCdf:UnkSrc',['Unknown Interference file "' tData.L2_SourceFiles.IntSource '"' ]));
	end
	if isempty(cGeoInfo)
		throw(MException('mkCrmCdf:UnkSrc',['Unknown GeoPhysical file "' tData.L2_SourceFiles.GeoSource '".'] ));
	end
end

function [nSrcId] = sourceId_(cPrimaryFile)
	
	lSrcName = split(cPrimaryFile, '_');
	if length(lSrcName) < 3
		throw(MExecption('mkCrmCdf:BadSrcName', [
			'Filename pattern for source ' cPrimaryFile ' is unrecognized'
		]));		
	end

	nSrcId = str2num(lSrcName{3});
end

